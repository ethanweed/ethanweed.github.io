<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Reading Experiment</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            text-align: center;
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
        }
        .canvas-container {
            position: relative;
            display: inline-block;
            margin: 20px auto;
            touch-action: none;
            width: 100%;
            max-width: 800px;
            border: 1px solid transparent;
        }
        #canvas {
            border: 2px solid #333;
            cursor: crosshair;
            display: block;
            width: 100%;
            height: auto;
        }
        .instructions {
            margin: 20px;
            font-size: 18px;
        }
        @media (max-width: 768px) {
            .instructions {
                font-size: 16px;
                margin: 15px;
            }
            .instructions h2 {
                font-size: 20px;
            }
            #canvas {
                width: 100% !important;
                height: auto !important;
            }
            .stats-container {
                flex-direction: column;
                align-items: center;
            }
            .stat-box {
                width: 100%;
                margin-bottom: 8px;
            }
        }

        #heatmap-container {
            margin-top: 20px;
            display: none;
        }
        #heatmap-canvas {
            border: 2px solid #333;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
        }
        /* Added to ensure heatmap image persists */
        #heatmap-image {
            border: 2px solid #333;
            display: none;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
        }
        .heatmap-legend {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 5px;
        }
        .legend-color {
            width: 20px;
            height: 15px;
            margin-right: 3px;
        }
        #raw-data-container {
            margin-top: 20px;
            text-align: left;
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            display: none;
        }
        #mouse-data {
            background: white;
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
            max-height: 300px;
            font-family: monospace;
            font-size: 12px;
            border: 1px solid #ddd;
        }
        .data-section {
            margin-top: 15px;
            border-top: 1px solid #ddd;
            padding-top: 15px;
        }
        .stats-container {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .stat-box {
            background: #f0f0f0;
            border-radius: 4px;
            padding: 8px 15px;
            margin: 5px;
            min-width: 150px;
        }

        /* Blur layer confined to canvas area */
        .blur-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            -webkit-backdrop-filter: blur(15px);
            backdrop-filter: blur(15px);
            mask-image: radial-gradient(circle 80px at -1000px -1000px, transparent 0%, #000 100%);
            -webkit-mask-image: radial-gradient(circle 80px at -1000px -1000px, transparent 0%, #000 100%);
            transition: mask-size .12s;
            z-index: 1;
        }

        .mobile-instructions {
            display: none;
            background: #e8f4fc;
            border: 1px solid #b3e0ff;
            border-radius: 5px;
            padding: 10px;
            margin: 10px;
            text-align: left;
        }

        /* DONE button styles - moved outside canvas container */
        #mobile-done-container {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: none;
            justify-content: center;
            z-index: 1000;
        }

        #mobile-done {
            background: #4285f4;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        * {
            -webkit-tap-highlight-color: rgba(0,0,0,0);
        }
    </style>
</head>
<body>
    <div class="instructions">
        <p><strong>Move your mouse or finger over the canvas to reveal hidden text</strong></p>
        <p>Press <strong>SPACEBAR</strong> (computer) or DONE (mobile) when finished to see your reading pattern and data</p>
    </div>


    <div class="canvas-container">
        <div class="blur-layer"></div>
        <canvas id="canvas" width="800" height="400"></canvas>
    </div>

    <!-- DONE button moved outside canvas container -->
    <div id="mobile-done-container">
        <button id="mobile-done">DONE</button>
    </div>

    <div id="heatmap-container">
        <h3>Reading Pattern Analysis:</h3>
        <div class="stats-container">
            <div class="stat-box">
                <strong>Total Time:</strong> <span id="total-time">0</span> ms
            </div>
            <div class="stat-box">
                <strong>Tracking Points:</strong> <span id="point-count">0</span>
            </div>
            <div class="stat-box">
                <strong>Reading Speed:</strong> <span id="reading-speed">0</span> points/sec
            </div>
        </div>
        <!-- Added persistent heatmap image -->
        <canvas id="heatmap-canvas" width="800" height="400" style="display: none;"></canvas>
        <img id="heatmap-image" alt="Heatmap visualization">
        <div class="heatmap-legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0, 0, 255, 0.7);"></div>
                <span>Less time</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0, 255, 255, 0.7);"></div>
                <span></span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0, 255, 0, 0.7);"></div>
                <span></span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 255, 0, 0.7);"></div>
                <span></span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 0, 0, 0.7);"></div>
                <span>More time</span>
            </div>
        </div>
    </div>

    <div id="raw-data-container">
        <h3>Raw Experiment Data:</h3>
        <div class="data-section">
            <h4>Mouse Tracking Data:</h4>
            <pre id="mouse-data"></pre>
        </div>
        <div class="data-section">
            <h4>Reading Statistics:</h4>
            <div id="statistics"></div>
        </div>
        <div class="data-section">
            <h4>Text Content:</h4>
            <div id="text-content" style="text-align: left; line-height: 1.5;"></div>
        </div>
    </div>

    <script>
        const isTouchDevice = 'ontouchstart' in window || 
                              navigator.maxTouchPoints > 0 || 
                              navigator.msMaxTouchPoints > 0;
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const blurLayer = document.querySelector('.blur-layer');
        const canvasContainer = document.querySelector('.canvas-container');

        // Fixed DONE button references
        const mobileDoneContainer = document.getElementById('mobile-done-container');
        const mobileDoneButton = document.getElementById('mobile-done');
        const mobileInstructions = document.querySelector('.mobile-instructions');

        const heatmapContainer = document.getElementById('heatmap-container');
        const heatmapCanvas = document.getElementById('heatmap-canvas');
        const heatmapImage = document.getElementById('heatmap-image');
        const heatmapCtx = heatmapCanvas ? heatmapCanvas.getContext('2d') : null;

        const rawDataContainer = document.getElementById('raw-data-container');
        const mouseDataElement = document.getElementById('mouse-data');
        const statisticsElement = document.getElementById('statistics');
        const textContentElement = document.getElementById('text-content');
        const totalTimeElement = document.getElementById('total-time');
        const pointCountElement = document.getElementById('point-count');
        const readingSpeedElement = document.getElementById('reading-speed');

        const mouseData = [];
        const startTime = Date.now();
        let isMouseInside = false;
        let experimentFinished = false;
        let lastTouchTime = 0;
        let containerRect = null;

        const experimentText = "In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the ends of worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or to eat: it a was a hobbit-hole, and that means comfort. It had a perfectly round door like a porthole, painted green, with a shiny yellow brass knob in the exact middle. The door opened on to a tube-shaped hall like a tunnel: a very comfortable tunnel without smoke, with panelled walls, and floors tiled and carpeted, provided with polished chairs, and lots and lots of pegs for hats and coats- the hobbit was fond of visitors. The tunnel wound on and on - going fairly but not quite straight into the side of the hill – The Hill, as all the people for many miles around called it – and many little round doors opened out of it, first on one side and then on another. No going upstairs for the hobbit: bedrooms, bathrooms, cellars, pantries (lots of these), wardrobes (he had whole rooms devoted to clothes), kitchens, dining-rooms, all were on the same floor, and indeed on the same passage. The best rooms were all on the left-hand side (going in), for these were the only ones to have windows, deep-set round windows looking over his garden, and meadows beyond, sloping down to the river.";

        const fontSize = 18;
        const lineHeight = 25;

        function getTextLines(text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            for (let word of words) {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);

                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            if (currentLine) {
                lines.push(currentLine);
            }
            return lines;
        }

        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#e0e0e0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'black';
            ctx.font = `${fontSize}px Arial`;
            const lines = getTextLines(experimentText, canvas.width - 40);
            lines.forEach((line, index) => {
                ctx.fillText(line, 20, 30 + (index * lineHeight));
            });
        }

        function initBlurPosition() {
            blurLayer.style.maskImage = 'radial-gradient(circle 80px at -1000px -1000px, transparent 0%, #000 100%)';
            blurLayer.style.webkitMaskImage = 'radial-gradient(circle 80px at -1000px -1000px, transparent 0%, #000 100%)';
        }

        function updateBlurPosition(clientX, clientY) {
            containerRect = canvasContainer.getBoundingClientRect();

            const x = clientX - containerRect.left;
            const y = clientY - containerRect.top;

            if (x >= 0 && y >= 0 && x <= containerRect.width && y <= containerRect.height) {
                const gradient = `radial-gradient(circle 80px at ${x}px ${y}px, transparent 0%, #000 100%)`;
                blurLayer.style.maskImage = gradient;
                blurLayer.style.webkitMaskImage = gradient;
                return true;
            }
            return false;
        }

        function resetBlurPosition() {
            blurLayer.style.maskImage = 'radial-gradient(circle 80px at -1000px -1000px, transparent 0%, #000 100%)';
            blurLayer.style.webkitMaskImage = 'radial-gradient(circle 80px at -1000px -1000px, transparent 0%, #000 100%)';
        }

        function generateHeatmap() {
            if (!heatmapCtx) return;

            try {
                heatmapCtx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
                heatmapCtx.fillStyle = '#e0e0e0';
                heatmapCtx.fillRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
                heatmapCtx.fillStyle = 'black';
                heatmapCtx.font = `${fontSize}px Arial`;
                const lines = getTextLines(experimentText, heatmapCanvas.width - 40);
                lines.forEach((line, index) => {
                    heatmapCtx.fillText(line, 20, 30 + (index * lineHeight));
                });

                const gridResolution = 10;
                const gridWidth = Math.ceil(heatmapCanvas.width / gridResolution);
                const gridHeight = Math.ceil(heatmapCanvas.height / gridResolution);
                const heatmapGrid = Array(gridWidth).fill().map(() => Array(gridHeight).fill(0));

                for (const point of mouseData) {
                    const gridX = Math.floor(point.x / gridResolution);
                    const gridY = Math.floor(point.y / gridResolution);

                    if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
                        heatmapGrid[gridX][gridY]++;
                    }
                }

                let maxCount = 0;
                for (let x = 0; x < gridWidth; x++) {
                    for (let y = 0; y < gridHeight; y++) {
                        maxCount = Math.max(maxCount, heatmapGrid[x][y]);
                    }
                }

                if (maxCount > 0) {
                    for (let x = 0; x < gridWidth; x++) {
                        for (let y = 0; y < gridHeight; y++) {
                            if (heatmapGrid[x][y] > 0) {
                                const normalized = heatmapGrid[x][y] / maxCount;
                                let r, g, b;
                                if (normalized < 0.25) {
                                    r = 0;
                                    g = Math.floor(normalized * 4 * 255);
                                    b = 255;
                                } else if (normalized < 0.5) {
                                    r = 0;
                                    g = 255;
                                    b = Math.floor((0.5 - normalized) * 4 * 255);
                                } else if (normalized < 0.75) {
                                    r = Math.floor((normalized - 0.5) * 4 * 255);
                                    g = 255;
                                    b = 0;
                                } else {
                                    r = 255;
                                    g = Math.floor((1 - normalized) * 4 * 255);
                                    b = 0;
                                }

                                heatmapCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${Math.min(0.7, normalized * 1.5)})`;
                                heatmapCtx.fillRect(
                                    x * gridResolution,
                                    y * gridResolution,
                                    gridResolution,
                                    gridResolution
                                );
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error generating heatmap:', error);
            }
        }

        // CRITICAL FIX: Convert canvas to image for persistence
        function convertHeatmapToImage() {
            if (!heatmapCanvas || !heatmapImage) return;

            try {
                // Get canvas data URL
                const dataURL = heatmapCanvas.toDataURL('image/png');

                // Set image source and display it
                heatmapImage.src = dataURL;
                heatmapImage.style.display = 'block';

                // Hide the canvas now that we have a persistent image
                heatmapCanvas.style.display = 'none';

                console.log('Heatmap converted to persistent image');
            } catch (error) {
                console.error('Error converting heatmap to image:', error);
            }
        }

        function displayRawData() {
            const totalTime = Date.now() - startTime;
            const pointsCount = mouseData.length;
            const readingSpeed = pointsCount > 0 ? Math.round(pointsCount / (totalTime / 1000)) : 0;

            totalTimeElement.textContent = totalTime;
            pointCountElement.textContent = pointsCount;
            readingSpeedElement.textContent = readingSpeed;

            const statsHTML = `
                <p><strong>Total experiment time:</strong> ${totalTime} milliseconds</p>
                <p><strong>Total tracking points:</strong> ${pointsCount}</p>
                <p><strong>Average tracking rate:</strong> ${readingSpeed} points per second</p>
                <p><strong>First position:</strong> x: ${mouseData[0]?.x || 'N/A'}, y: ${mouseData[0]?.y || 'N/A'}</p>
                <p><strong>Last position:</strong> x: ${mouseData[pointsCount-1]?.x || 'N/A'}, y: ${mouseData[pointsCount-1]?.y || 'N/A'}</p>
            `;
            statisticsElement.innerHTML = statsHTML;

            const formattedData = JSON.stringify({
                total_time_ms: totalTime,
                total_mouse_points: pointsCount,
                mouse_positions: mouseData,
                text_content: experimentText
            }, null, 2);

            mouseDataElement.textContent = formattedData;
            textContentElement.textContent = experimentText;
        }

        function setupEventListeners() {
            // Mouse event handlers
            canvas.addEventListener('mouseenter', function() {
                isMouseInside = true;
            });

            canvas.addEventListener('mouseleave', function() {
                isMouseInside = false;
                resetBlurPosition();
            });

            canvas.addEventListener('mousemove', function(event) {
                if (experimentFinished) return;
                updateBlurPosition(event.clientX, event.clientY);
                recordPositionIfInside(event.clientX, event.clientY);
            });

            // Touch event handlers
            canvasContainer.addEventListener('touchstart', function(event) {
                event.preventDefault();
                isMouseInside = updateBlurPosition(event.touches[0].clientX, event.touches[0].clientY);
                if (isMouseInside) {
                    recordPosition(event.touches[0].clientX, event.touches[0].clientY);
                }
            }, { passive: false });

            canvasContainer.addEventListener('touchmove', function(event) {
                const now = Date.now();
                if (now - lastTouchTime < 300) {
                    event.preventDefault();
                }
                lastTouchTime = now;

                isMouseInside = updateBlurPosition(event.touches[0].clientX, event.touches[0].clientY);
                if (isMouseInside) {
                    recordPosition(event.touches[0].clientX, event.touches[0].clientY);
                }
            }, { passive: false });

            canvasContainer.addEventListener('touchend', function() {
                isMouseInside = false;
                resetBlurPosition();
            });

            canvasContainer.addEventListener('touchcancel', function() {
                isMouseInside = false;
                resetBlurPosition();
            });

            // Record position only if inside container
            function recordPosition(clientX, clientY) {
                containerRect = canvasContainer.getBoundingClientRect();

                const x = clientX - containerRect.left;
                const y = clientY - containerRect.top;

                if (x >= 0 && y >= 0 && x <= containerRect.width && y <= containerRect.height) {
                    mouseData.push({
                        x: Math.round(x),
                        y: Math.round(y),
                        timestamp: Date.now() - startTime
                    });
                }
            }

            function recordPositionIfInside(clientX, clientY) {
                if (updateBlurPosition(clientX, clientY)) {
                    recordPosition(clientX, clientY);
                }
            }

            // Spacebar handler
            document.addEventListener('keydown', function(event) {
                if (event.code === 'Space' && !experimentFinished) {
                    completeExperiment();
                }
            });

            // DONE button handler
            if (mobileDoneButton) {
                mobileDoneButton.addEventListener('click', function(event) {
                    event.stopPropagation();
                    event.preventDefault();
                    completeExperiment();
                    return false;
                });

                mobileDoneButton.addEventListener('touchstart', function(event) {
                    event.stopPropagation();
                }, { passive: false });

                mobileDoneButton.addEventListener('touchend', function(event) {
                    event.stopPropagation();
                    event.preventDefault();
                    completeExperiment();
                    return false;
                }, { passive: false });
            }
        }

        function completeExperiment() {
            console.log('Completing experiment');
            experimentFinished = true;

            if (canvasContainer) {
                canvasContainer.style.display = 'none';
            }

            // Hide mobile done button container
            if (mobileDoneContainer) {
                mobileDoneContainer.style.display = 'none';
            }

            const instructions = document.querySelector('.instructions');
            if (instructions) {
                const firstParagraph = instructions.querySelector('p:first-child');
                const lastParagraph = instructions.querySelector('p:last-child');

                if (firstParagraph) {
                    firstParagraph.textContent = 'Your reading analysis:';
                }
                if (lastParagraph) {
                    lastParagraph.style.display = 'none';
                }
            }

            // Generate heatmap first
            generateHeatmap();

            // CRITICAL FIX: Convert to image for persistence
            convertHeatmapToImage();

            // Show heatmap container
            if (heatmapContainer) {
                heatmapContainer.style.display = 'block';
            }

            // Display raw data
            displayRawData();
            if (rawDataContainer) {
                rawDataContainer.style.display = 'block';
            }

            console.log('Results displayed successfully');
        }

        function init() {
            try {
                function resizeCanvas() {
                    containerRect = canvasContainer.getBoundingClientRect();
                    const containerWidth = containerRect.width;
                    const aspectRatio = 2;
                    const canvasHeight = Math.round(containerWidth / aspectRatio);

                    canvas.width = containerWidth;
                    canvas.height = canvasHeight;

                    drawCanvas();

                    if (heatmapCanvas) {
                        heatmapCanvas.width = containerWidth;
                        heatmapCanvas.height = canvasHeight;
                    }
                }

                resizeCanvas();

                let resizeTimeout;
                window.addEventListener('resize', function() {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(resizeCanvas, 100);
                });

                setupEventListeners();
                drawCanvas();
                initBlurPosition();

                if (isTouchDevice) {
                    console.log('Touch device detected:', isIOS ? 'iOS' : 'non-iOS');

                    if (mobileInstructions) {
                        mobileInstructions.style.display = 'block';
                    }

                    // Show mobile done button container
                    if (mobileDoneContainer) {
                        mobileDoneContainer.style.display = 'flex';
                    }

                    const instructions = document.querySelector('.instructions p:first-child');
                    if (instructions) {
                        instructions.textContent = 'Drag your finger across the text box to reveal hidden text';
                    }

                    if (isIOS) {
                        console.log('iOS-specific fixes applied');
                        setTimeout(() => {
                            canvasContainer.style.opacity = '0.99';
                            setTimeout(() => {
                                canvasContainer.style.opacity = '1';
                            }, 10);
                        }, 100);
                    }
                }

                console.log('Experiment initialized successfully');
            } catch (error) {
                console.error('Initialization error:', error);
            }
        }

        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            init();
        } else {
            document.addEventListener('DOMContentLoaded', init);
        }
    </script>
</body>
</html>
